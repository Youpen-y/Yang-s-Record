Bip Buffer —— 一种改进的循环缓冲（Ring Buffer）

>[!REF]
>[Simon Cooke "The Bip Buffer - The Circular Buffer with a Twist" ](https://www.codeproject.com/Articles/3479/The-Bip-Buffer-The-Circular-Buffer-with-a-Twist)

`Bip-Buffer` 不像循环缓冲区那样维护一个指向缓冲区中数据 `head` 和 `tail` 的指针，而是
- 维护两个轮转区域，允许快速访问数据，而不必担心在缓冲区的末尾进行环绕（wrap around）。
- 缓冲区分配（Buffer Allocations）始终保持为连续的块，从而允许以高效的方式用 API 调用使用缓冲区，而且降低了将数据放入缓冲区所需的拷贝量。
- 两阶段分配系统允许用户保守地预留一块缓冲区区域，然后修剪缓冲区，仅提交已使用的空间

循环缓冲区的缺点：内存块可能在物理上不连续（越过缓冲区末尾发生环绕，尽管在逻辑上是连续的），大多数 API 调用不能直接使用其返回的内存块，原因是必须传给它们可以访问的连续内存块。

背后思想
构建一个分为两个区域的循环缓冲区（或者说是二分的），两个区域中的每一个都在缓冲区中移动，从左侧开始（start），在右侧结束（end）。
当一个用完了用于追加数据的空间，如果只有一个区域，则在起始处创建一个新的区域。

![[Bip Buffer.png]]
1. 缓冲区开始是空的
2. 当数据第一次放入缓冲区时，会创建一个区域（`A` 区域），即在调用 reserve, commit 后
3. 数据被添加到该区域，向右扩展
4. 从缓冲区删除数据
5. 删除数据可以持续到到达缓冲区的末尾，一旦区域 A 左侧的可用空间比右侧多，则在左侧创建第二个区域 B 。
6. 使用更多的缓冲区空间，新的空间只从区域 B 的末尾分配。
7. 如果我们最终分配了足够的数据来使用区域 A 和 B 之间的所有空闲空间，那么缓冲区中将不再有任何可用空间。即在读取数据之前，无法执行更多的预留。
8. 如果我们从缓冲区读取更多的数据（比如，A 的所有剩余内容），我们会完全耗尽它。这时，由于 A 区域完全是空的，我们不再需要跟踪两个单独的区域，区域 B 的所有属性数据将被复制到 A 的属性数据上。
9. 从缓冲区读取更多的数据，将得到图 4 相似的结果，循环继续。

特性：缓冲区总是有相对最大的可用空间，而不需要任何数据拷贝或重新分配来释放缓冲区末尾的空间。

从实现的角度来看，常规循环缓冲区和 Bip Buffer 之间最大的区别是，**Bip Buffer 只返回连续的块**。
在一些循环缓冲区实现中（将数据作为指针和长度传入缓冲区），然后将数据逐字节复制到缓冲区以考虑边缘环绕（wrapping at the edges）。






