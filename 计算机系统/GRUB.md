GRUB（GNU GRand Unified Bootloader）源自 GNU project 的 `bootloader` 包。[多重引导规范](https://www.gnu.org/software/grub/manual/multiboot/multiboot.html)的参考实现，用户可用它来选择引导计算机上安装的多个操作系统之一，或选择特定操作系统分区上可用的特定内核配置。
简而言之，`bootloader` 是计算机启动时运行的第一个软件程序。负责加载控制权并将其转移给操作系统内核软件（如 `Hurd` 或 `Linux`），内核依次初始化操作系统的其他部分。

GRUB2 取代了之前的 GRUB（即版本 0.9x，GRUB Legacy 不再被开发）。
扩展：[GRUB2](https://glennastory.net/boot/grub2.html)
---
当计算机打开时，BIOS 会查找可引导设备（primary bootable device，通常是计算机的硬盘）并从主引导记录（master boot record，MBR）运行初始引导程序。MBR 是硬盘的第一个扇区，该引导程序必须很小，因为它必须适合（fit in）单个扇区。长期以来，一个扇区的大小一直是 512 字节。其中分区表信息： 64 字节，磁盘签名：4字节，磁盘时间辍：6字节。
- 不使用磁盘签名和时间辍：446 字节可用
- 使用磁盘签名和时间辍：434 字节可用
该空间对于简单的引导加载程序是足够的，但无法容纳支持复杂和多个文件系统、菜单驱动的引导选择等的引导加载程序。具有更大占用空间的引导加载程序因此分成多个片段，其中最小的片段适合 MBR ，而一个或多个较大的片段存储在其他位置，如 MBR 和第一个分区之间的空扇区。MBR 中的代码只不过是开始第二部分而已。

引导加载程序的其余部分的目的是通过配置操作系统并启动内核来实际引导操作系统，在大多数情况下，内核作为文件存储在适当的文件系统上，但 BIOS 不知道文件系统的概念。因此，在基于 BIOS 的系统中，引导加载程序的职责是访问这些文件的内容，以便将其加载到 RAM 中并执行。

#### 一、直接访问硬盘扇区加载内核映像
这种方式无需了解文件系统。通常，需要额外的间接级别，以映射（maps）或映射文件（map files）的形式 - 包含内核映像占用的物理扇区列表的辅助文件。此映射（map）需要在每次内核更新其磁盘上的位置时更新（由于安装新的内核映像、文件系统碎片整理等）。此外，如果 map 本身改变其物理位置，需要在更新 bootloader's MBR 代码中 map 的位置。


#### 二、引导加载程序了解底层文件系统，使用其实际文件路径来配置和访问内核映像
这需要引导加载程序包含每个受支持的文件系统的驱动程序，以便引导加载程序本身可以理解和访问它们。这种方法不需要硬盘扇区的硬编码位置和映射文件的存在，并且在添加或移动内核映像后不需要更新 MBR。引导加载程序的配置存储在常规文件中，也可以通过文件系统感知的方式访问该文件，以在实际引导任何内核映像之前获取引导配置。因此，系统更新期间出错的可能性会更少。缺点是此类引导加载程序更大且更复杂。

GNU GRUB 使用第二种方法，通过了解底层文件系统。引导加载程序本身分为多个阶段，以便适合 MBR 引导方案。
常用的 GRUB 有两个主要版本： GRUB 版本 0，称为 GRUB 旧版，仅在较旧版本的 Linux 发行版中流行。 GRUB 2是从头开始编写的，旨在取代其前身，现在已被大多数 Linux 发行版使用。

![[GNU GRUB 2.png]]

- `boot.img` （阶段 1） ，被写入主引导记录（扇区 0 中的MBR引导代码）的前 440 字节，或者可选地写入分区引导扇区（PBR）。通过 64 位 LBA 地址对 `diskboot.img` 进行寻址。实际扇区号由 `grub-install` 写入。`diskboot.img` 是 `core.img` 的第一个扇区，其唯一目的是加载由同样由 `grub-install` 写入的 LBA 扇区号标识的 `core.img` 的其余部分。
	- 在 MBR 分区磁盘上， `core.img` （**阶段 1.5** ）存储在 MBR 和第一个分区之间的空扇区（如果可用）中。最近的操作系统建议在此处使用 1 MiB 间隙进行对齐（2047 个 512 字节或 255 个 4 KiB 扇区）。这个间隙曾经是 62 个扇区 (31 KiB)，提醒人们 1996 年之前BIOS使用的[柱面-磁头-扇区](https://en.wikipedia.org/wiki/Cylinder-Head-Sector "Cylinder-Head-Sector")(C/H/S) 寻址的扇区数限制，因此`core.img`设计为小于 32 KiB。
	- 在 GPT 分区磁盘上`core.img`被写入其自己的分区。它必须标记为“BIOS_grub”，不得格式化，并且可以小至 1 MiB。
- 阶段 2 ：`core.img`从`grub-install`配置的分区加载`/boot/grub/i386-pc/normal.mod` 。如果分区索引已更改，GRUB 将无法找到`normal.mod` ，并向用户显示 GRUB Rescue 提示。
- 根据 GRUB2 的安装方式， `/boot/grub/`位于 Linux 发行版的根分区（root partition）中，或者位于单独的 `/boot` 分区中。
- 加载 `normal.mod`后： `normal.mod`解析`/boot/grub/grub.cfg` ，选择性地加载模块（例如，用于图形UI和文件系统支持）并显示菜单。
#### 在使用 UEFI 的固件的系统上启动
- `/efi/<distro>/grubx64.efi` （对于x64 UEFI 系统）作为文件安装在 EFI 系统分区中，并由固件直接启动，在 MBR 扇区 0 中没有`boot.img` 。该文件类似于 stage1和阶段1.5。
- `/boot/grub/`可以安装在 EFI 系统分区或单独的_/boot_分区等上。
- 对于 x64 UEFI 系统，stage2 是 `/boot/grub/x86_64-efi/normal.mod` 文件和其他`/boot/grub/`文件。
#### 启动后
GRUB 提供一个菜单，用户可以在其中从 `grub-install` 找到的操作系统（OS）中进行选择。GRUB 可以配置为在用户定义的超时后自动加载指定的操作系统。如果超时设置为零秒，按住 `Shift` / `Esc` 键，在计算机启动时访问启动菜单。

在操作系统选择菜单中， GRUB 接受几个命令：
- 按 `e` ，在操作系统启动之前编辑所选菜单项的内核参数。
- 按 `c` ，用户进入 GRUB 命令行。GRUB 命令行类似于 GNU Bash ，但仅实现行编辑功能和 GRUB 特定命令的子集。
选择引导选项后，GRUB 将所选内核加载到内存中并将控制权传递给内核。