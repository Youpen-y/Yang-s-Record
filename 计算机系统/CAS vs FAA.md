>[!REF]
>[CAS and FAA](https://medium.com/@pravvich/cas-and-faa-through-the-eyes-of-a-java-developer-8a028f213624)

CAS（`compare_and_swap`）和 FAA（`fetch_and_add`）是原子操作，旨在确保多线程应用程序中的线程安全和同步。
- CAS 允许将变量的值与预期值进行比较，并在比较成功时自动更新它
- FAA 提供变量的原子增量或减量，是计数器和聚合器的理想选择

CAS 操作包括三个数：存储单元地址（V）、预期旧值（A）和新值（B）。
如果内存单元中的值与预期旧值匹配，则处理器自动更新内存单元中的值为新值；否则，不记录修改。（_有的 CAS 实现返回之前存在的值；有的返回操作成功的信息，而非当前值_）

CAS 使用特殊的处理器指令在硬件中实现，以保证该操作的原子性。因此，CAS 在更新共享数据时提供高性能和低延迟。
硬件层面关键点：
- 原子性，该指令要么完全执行，要么根本不执行。
- 可寻址，必须指定变量在内存中所存在的位置
- 比较，将变量的值与期望的值进行比较；若值匹配，则指令将新值写入内存
- 原子写入，CAS 指令必须将变量的新值原子写入内存

处理可以实现不同的 CAS 机制。比如，某些处理器可能使用特殊寄存器来存储变量的当前值和期望值，这种情况下，将在寄存器中比较这些值，如果匹配，则将新值写入内存。
其他处理器可能使用更复杂的机制，即使用高速缓存和多线程。这种情况下，将在缓存中比较这些值，如果值匹配，则将新值写入内存。

因此，CAS在硬件层面的操作取决于处理器微架构中的具体实现。然而，无论具体实现如何，CAS指令都保证了读取、检查和更改变量值操作的原子性。
如，
- Intel x86：Intel x86 处理器支持 CAS 指令，该指令将变量的值与预期值进行比较，如果匹配则写入新值。该指令在实模式和保护模式下均可用。
- ARM：ARM 处理器支持 LDREX（加载独占）指令来读取变量的值，并支持 STREX（存储独占）指令来将新值写入变量（如果变量自读取后未发生更改）。两条指令必须在单个事务中执行。
- PowerPC：PowerPC 处理器支持 LWARX（加载字和保留）指令来读取变量的值并保留相应的内存，以及 STWCX（条件存储字）指令来将新值写入变量（如果还没有）已被其他处理器修改。
- SPARC：SPARC 处理器支持 CASA（比较和交换原子）指令，将变量的值与预期值进行比较，如果匹配则写入新值。该指令可用于对 32 位和 64 位值进行原子操作。
- IBM z/Architecture：IBM z/Architecture 处理器支持 CS（比较和交换）指令，用于将变量的值与预期值进行比较，如果匹配则写入新值。该指令可用于对 32 位和 64 位值进行原子操作。

CAS 优缺点
优点
- 与传统锁定机制相比，操作快速且成本低廉。
- 非阻塞，减少死锁的可能性并提高应用程序性能。
- 使能可在低争用（线程之间的竞争）下有效工作的乐观同步策略
缺点
- CAS 可能会导致“饥饿”问题，即一个线程不断尝试执行 CAS 操作，但由于与其他线程竞争而无法执行。
- CAS 操作可能会导致“ABA 问题”，即变量的值从 A 更改为 B，然后又返回到 A，这可能会导致某些算法出现错误。

FAA（`Fetch-and-Add`）读取变量的当前值，向其添加指定的数字，然后返回变量的旧值。

FAA 涉及​​两个操作数：存储器位置的地址 (V) 和要添加到存储在存储器位置 (V) 的旧值的值 (S)。因此，FAA可以表示为：提取指定地址（V）处的值并暂时存储。然后，将先前存储的值（增加第二个操作数 (S) 的值）写入指定地址 (V)。需要注意的是，所有上述操作都是原子执行的，并在硬件级别实现。

与CAS一样，处理器必须保证FAA操作的原子执行，以保证多线程应用程序的正确运行。 FAA机制在硬件层面的具体实现取决于具体的处理器架构。

FAA 优点：
- 与传统锁定机制相比，操作快速且成本低廉。
- 非阻塞方法减少了死锁的可能性并提高了应用程序性能。
- 简化原子计数器和聚合器的实现。
缺点：
- 可能并不适合所有用例，因为它假设固定数量的原子增量，这可能不是所有任务的通用解决方案。





