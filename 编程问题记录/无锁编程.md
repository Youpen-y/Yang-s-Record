无锁编程（lock-free programming） 是一种允许共享数据结构的并发更新而不需要在线程之间执行昂贵的同步的技术。该方法确保没有线程一直阻塞，并且在由多个线程时保证某些线程继续推进。

无锁编程的优点：
- 可用于必须避免锁的地方。如中断处理程序
- 避免阻塞带来的麻烦，如死锁和优先级反转
- 提高多核处理器的性能

C11 中增加的多线程支持，使得我们使用更高级别的编程类型来处理并发。

C11 定义了一个新的 `_Atomic` 类型说明符。原子声明语法如下：
```c
#include <stdatomic.h>

_Atomic(typename) var1;	// or
_Atomic typename var2;

struct Node
{
	int data;
	struct Node *next;
};
_Atomic struct Node s;	// s is also an atomic type object
```

对 C11 原子变量的每次访问都有一个明确的“内存模型”与之关联。内存模型描述了处理器或编译器如何优化对内存的访问。
宽松的模型可以允许操作重新排序或组合以提高性能。
默认模型（“顺序一致”）是最严格的，而且大多数时候，正确操作不需要花费这些费用。存在更宽松的模型，允许以受控的方式执行优化，同时确保在需要时正确排序。


---
[C11 atomic variables and the kernel](https://lwn.net/Articles/586838/)
C11 原子变量包含一些在内核通常用内存屏障实现的特性。如，内核中的
```c
smp_store_release(&x, new_value);
```
`smp_store_release()` 内存屏障告诉处理器确保在对 `x` 的赋值变得可见之前，在此赋值之前执行的任何读或写在所有处理器上都是可见的。所有发生在此屏障之前的操作的重新排序仍然是可能的，所有发生在此屏障之后的操作的重新排序也是可能的。在大多数代码中，可以在不影响结果正确性的情况下进行相当多的重新排序。在顺序确实重要的地方使用显式屏障可以使大多数访问在没有屏障的情况下执行，从而实现优化并显着提高性能。

如果 `x` 是 C11 原子类型，可以这样写：
```c
atomic_store(&x, new_value, memory_order_release);
```
其中 `memory_order_release` 指定与 `smp_store_release()` 相同的顺序要求。

如果使用 `memory_order_relaxed` 模型（对访问没有顺序要求）来包围对其他原子变量的访问，并且顺序并不重要，最终结果与 `smp_store_release()` 实现结果相同。但 `smp_store_release()` 是在内核中使用棘手的、特定于体系结构的代码来实现的；而 `atomic_store` 是编译器直接产生的代码。

当内核第一次获得对多处理器系统的支持时， C 语言还没有原子类型或内存屏障的概念，因此内核开发人员自然必须创建自己的。如今，语言标准已经赶上了，修改内核以使用标准原子类型是有意义的。

使用忧虑：
编译器通常会最大限度地优化代码。然而这些优化会破坏那些没有按照标准编写的代码。
高度并发的代码，如在内核中发现的，往往比其他任何东西更容易受到优化引起的问题的影响，所以内核开发人员对此很小心。
潜在问题1：猜测存储（`speculative stores`），其中一个错误的值短暂可见。
如：代码
```c
if (x)
	y = 1;
else
	y = 2;
```
经常被优化为
```c
y = 2;
if (x)
	y = 1;
```
对于那些在自己的地址空间中操作的顺序代码，最终结果相同，并且后者避免了一次跳转。但如果 `y` 在其他地方可见，那么在 `test` 之前猜测存储的值可能被代码看到，从而导致出错。
显然，如果系统要正确运行，就必须避免导致不正确的值对任何正在运行的线程可见的优化。

另一个需要关系的地方是控制依赖性（`control dependencies`） ：原子变量与控制流交互的情况。
如：
```c
x = atomic_load(&a, memory_order_relaxed);
if (x)
	atomic_store(&y, 42, memory_order_relaxed);
```
y 的设置与 x 的值有控制依赖，但 C11 标准目前根本没有解决控制依赖性，这意味着编译器或处理器可以处理（play with）两个原子操作的顺序，甚至尝试完全优化分支。但在内核中进行这种优化的结果可能是灾难性的。
Linus 认为，任何以外部可见的方式移动 `atomic_store()` 操作的编译器都是错误的。

值推测（`value speculation`）问题，即编译器猜测一个变量将有一个特定的值，如果猜测是错误的，就插入一个分支来修复。处理器的分支预测硬件将有望在预测正确的情况下加快速度。好消息是标准似乎不会允许这种预测。

另一个问题是全局优化（`global optimization`），越来越多的编译器开发人员试图在整个源文件甚至更大的文件组级别上优化程序。
只要编译器真正理解变量的使用方式，这种优化就可以很好地工作。但是编译器并不需要理解程序运行的真实的硬件；相反，它需要证明它的决定是针对标准定义的虚拟机的，如果真实的计算机的行为方式与虚拟机不同，则可能会出错。

解决许多非本地问题的一个解决方案是使用 `volatile` 包含受影响的变量。但使用 `volatile` 关闭了对受影响变量的所有优化，这首先就违背了使用原子变量的目的。如果必须使用 `volatile` ，内核最好还是保持当前的内存屏障方案，该方案旨在允许尽可能多的编译器和处理器级优化，但不能超过此。



