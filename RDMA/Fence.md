### 什么是 `Fence` ？
在发送队列中，有些操作从本地主机向远程主机发送数据，有些操作从远程主机读取数据并将其存储在本地。

有时，需要从远程主机读取数据并将其全部/部分发送回。显然，这应该在两个单独的发送请求中完成。某些操作可能会在之前的操作结束之前开始处理，这可能会导致发送意外的内存内容。此外，从远程读取地址然后写入（直接使用 RDMA Write 和 Atomic 或间接通过 Send）可能会导致意外行为。

上述场景的简单解决方案：为第一个操作发布一个 `Send Request` ，等待它完成（即轮询其工作完成情况），然后发布第二个 `Send Request` 。
这种方案可以工作，但与同时发布这个 `Send Requests` 相比，会消耗更多的 CPU 时间，并且会产生较差的延迟。

RDMA 提供了一种强制发送请求处理顺序的机制：`Fence` 。当发送请求上存在 Fence Indicator 时，只有在同一发送队列上的所有先前 RDMA 读取和原子操作完成后，才会开始处理。这仅与可靠的队列对相关（只有它们支持这些操作）

Fence 保证发布到同一发送队列的发送请求的处理顺序和完成通知。多个发送队列之间的顺序未定义。

### 如何使用？
可以通过设置发送请求的 `send_flags` 字段中的 `IBV_SEND_FENCE` 位并调用 `ibv_post_send()` 来使用 Fence 。


### 什么时候使用 `Fence` ？
经验显示，当 RDMA 读取或原子操作后紧跟 Send 、RDMA Write 或 Atomic 操作并且第一个操作可能未完成时，应使用 Fence 。

使用/不使用 Fence 时可能发生的情况以及它如何影响发送请求处理顺序：
- `RDMA Read`：RDMA 读取后跟 Send 、RDMA Writes 或 Atomic 操作
	- 不使用 Fence 可能会导致 RDMA Read 到的数据将包含由第二个操作修改的数据。
	- 使用 Fence 将确保第一个操作读取的数据将是原始（和预期）数据。
- RDMA Read or Atomic operations 后跟 Sends 、RDMA Writes 或 Atomic 操作
	- 不设置 Fence 可能会导致如果发起方的第一个操作错误完成（因为其 ACK 未能返回，写入时本地保护错误）数据或任何其他原因，并且第二个操作仍然可以被目标观察到，甚至可能导致数据被写入目标的内存中。
	- 使用 Fence 可以在一个操作失败的情况下阻止目标观察到第二个操作。

